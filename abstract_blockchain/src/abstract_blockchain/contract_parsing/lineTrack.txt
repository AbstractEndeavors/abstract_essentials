{'declared': [], 'variables': [], 'currLineChop': '', 'currLineAttrib': [], 'currPrase': '', 'newLine': '', 'currPhrase': '', 'pragma solidity': {'names': ['^0.8.13', '^0.8.0', '^0.8.0', '^0.8.0', '^0.8.0']}, 'currSect': 'contract', 'library': {'names': ['SafeMath', 'NeFiLib', 'Address', 'SafeERC20'], 'SafeMath': {'attributes': [], 'names': {}, 'funcs': ['tryDiv', 'tryMod', 'add', 'sub', 'mul', 'div', 'mod']}, 'NeFiLib': {'attributes': ['SafeMath'], 'names': {}, 'funcs': ['addressInList', 'getAllMultiple', 'getDecimals', 'elimZero', 'sendPercentage', 'getRemainder', 'getMultiple', 'doMultiple', 'findInList', 'isLower', 'isHigher', 'isEqual', 'getLower', 'getHigher'], 'loops': {'for': {'vars': [['uint i=0', 'i<_list.length', 'i++'], ['uint i = 0', 'i<_ls.length', 'i++']], 'funcs': [['if(_account == _list[i]){', 'return true', '}'], ['if(_ls[i] == _account){', 'return i', '}']]}, 'while': {'vars': [['z >= _x'], ['_x != 0'], ['_n ==0 && refDec!=0'], ['_x > One']], 'funcs': [['', 'z -=_x', 'i++', ''], ['_x = _x.div(10)', 'i++'], ['refDec -= 1', '_n = _y.div(10**refDec)', 'k +=1'], ['_z += _y', '_x.sub(One); ']]}}}, 'Address': {'attributes': [], 'names': {}, 'funcs': ['isContract', 'sendValue', 'functionCall', 'functionCallWithValue', 'functionStaticCall', 'functionDelegateCall', 'verifyCallResult']}, 'SafeERC20': {'attributes': ['Address'], 'names': {}, 'funcs': ['safeTransfer', 'safeTransferFrom', 'safeApprove', 'safeIncreaseAllowance', 'safeDecreaseAllowance', '_callOptionalReturn']}}, 'currSub': 'function', 'abstract contract': {'names': ['Context', 'Ownable', 'boostManager', 'overseer'], 'Context': {'attributes': [], 'names': {}, 'funcs': ['_msgSender', '_msgData']}, 'Ownable': {'attributes': ['Context'], 'names': {}, 'funcs': ['owner', 'renounceOwnership', 'transferOwnership', '_transferOwnership'], 'constructor': {'vars': [{}], 'attributes': []}, 'modifier': {'names': ['onlyOwner()'], 'funcs': [(['    modifier onlyOwner() {', '        require(owner() == _msgSender(), "Ownable: caller is not the owner");', '        _;', '    }'], '{    modifier onlyOwner() {        require(owner() == _msgSender(), "Ownable: caller is not the owner");        _;    }')]}}, 'boostManager': {'attributes': ['Context'], 'names': {'boostMGR': {'address': '_account'}}, 'funcs': ['getIncreasedDecay']}, 'overseer': {'attributes': ['Context'], 'names': {'over': {'address': '_account'}}, 'funcs': ['getFee']}}, 'interface': {'names': ['IERC20', 'IERC20Metadata'], 'IERC20': {'attributes': [], 'names': {'feeTok': {'address': '_addresses[2]'}, 'NeFi': {'address': 'NeFiToken'}, 'IERC20(token)': {'address': ''}, 'IERC20(_token)': {'address': ''}}, 'funcs': ['totalSupply', 'balanceOf', 'transfer', 'allowance', 'approve', 'transferFrom']}, 'IERC20Metadata': {'attributes': ['IERC20'], 'names': {}, 'funcs': ['name', 'symbol', 'decimals']}}, 'contract': {'names': ['ERC20', 'NeFiFeeManager'], 'ERC20': {'attributes': ['Context', 'IERC20', 'IERC20Metadata'], 'names': {}, 'funcs': ['name', 'symbol', 'decimals', 'totalSupply', 'balanceOf', 'transfer', 'allowance', 'approve', 'transferFrom', '_transfer', '_approve', '_beforeTokenTransfer', '_afterTokenTransfer'], 'mapping': {'names': ['=>'], 'funcs': [], '=>': {'variables': [{'type': '(', 'name': 'uint256)'}, {'type': '(', 'name': 'uint256))'}]}}, 'constructor': {'vars': [{'type': 'string', 'name': 'name_'}, {'type': 'string', 'name': 'symbol_'}], 'attributes': []}}, 'NeFiFeeManager': {'attributes': ['Ownable', 'SafeMath'], 'names': {}, 'funcs': ['payFeeAvax', 'divyERC', 'MGRrecPayFees', 'reconcileFees', 'reconcileAccountFees', 'INTreconcileAccountFees', 'INTreconcileFees', 'getTotalfees', 'findLowest', 'EXTnameExists', 'nameExists', 'INTupdateName', 'EXTfindFromName', 'findFromName', 'INTupdateProtos', 'bytesToAddress', 'addProto', 'INTaddProto', 'collapseProto', 'INTcollapse', 'INTupdateTotalPayable', 'INTupdateFutureFees', 'INTupdateFeesPaid', 'INTupdateProtoNextDue', 'INTqueryProtoFutureFees', 'INTqueryProtoTotalPayable', 'updateFeesPaid', 'INTupdateProtoIncreasedDecay', 'INTupdateProtoFeeFroze', 'INTupdateFeeFroze', 'INTqueryProtoElapsed', 'INTqueryProtoDueElapsed', 'INTqueryProtoCollapseDate', 'INTupdateBoolImploded', 'INTupdateBoolCollapsed', 'INTqueryBoolOwed', 'INTqueryBoolInsolvent', 'INTgetBoolImploded', 'INTgetInsolvent', 'INTgetName', 'INTgetTotalPayable', 'INTgetFeeFroze', 'INTgetProtoDueElapsed', 'INTgetFeesOwed', 'INTgetProtoElapsed', 'INTgetBoolOwed', 'INTgetBoolInsolvent', 'INTgetProtos', 'INTgetFutureFees', 'INTgetFeesPaid', 'INTgetProtoCreationDate', 'INTgetProtoNextDue', 'INTgetProtoFutureFees', 'INTgetProtoIncreasedDecay', 'INTgetProtoCollapseDate', 'INTgetProtoFeeFroze', 'INTgetProtoTotalPayable', 'INTgetBoolCollapsed', 'INTgetImploded', 'INTgetCollapsed', 'updateBoolOwed', 'updateTotalPayable', 'updateProtos', 'updateFeesOwed', 'updateFutureFees', 'updateCollapsed', 'updateFeeFroze', 'updateInsolvent', 'updateImploded', 'updateName', 'updateProtoCreationDate', 'updateProtoCollapseDate', 'updateProtoNextDue', 'updateBoolCollapsed', 'updateProtoFutureFees', 'updateProtoIncreasedDecay', 'updateProtoFeeFroze', 'updateBoolImploded', 'updateProtoTotalPayable', 'getProtoOwnersLength', 'getTotalPayable', 'getProtos', 'getFeesOwed', 'getFutureFees', 'getFeesPaid', 'getInsolvent', 'getFeeFroze', 'getName', 'getProtoCreationDate', 'getProtoCollapseDate', 'getProtoNextDue', 'getProtoIncreasedDecay', 'getProtoFutureFees', 'getProtoFeeFroze', 'getProtoTotalPayable', 'getBoolInsolvent', 'getBoolImploded', 'getBoolCollapsed', 'getProtoowners', 'getProtoownersAccountsLength', 'getProtoAddress', 'getBool', 'getProtoownersLength', 'INTgetProtoownersLength', 'pauseFees', 'removeManagers', 'updateManagers', 'changeMaxPeriods', 'changeFeePeriod', 'changeNeFiTokenAddress', 'changeTreasury', 'changeGuard', 'boostit', 'changeOverseer', 'changeBoostManager', 'updateTeamPool', 'updateRewardsPool', 'updateRewards_team_treasuryPercentage', 'transferOut', 'transferAllOut', 'sendAllTokenOut'], 'structs': {'names': [' TOTALFEES', ' PROTOOWNERS', ' BOOL'], ' TOTALFEES': {'variables': [{'type': 'uint256', 'name': 'protos'}, {'type': 'uint256', 'name': 'feesOwed'}, {'type': 'uint256', 'name': 'futureFees'}, {'type': 'uint256', 'name': 'feesPaid'}, {'type': 'uint256', 'name': 'collapsed'}, {'type': 'uint256', 'name': 'feeFroze'}, {'type': 'uint256', 'name': 'insolvent'}, {'type': 'uint256', 'name': 'imploded'}]}, ' PROTOOWNERS': {'variables': [{'type': 'uint256', 'name': 'protoCreationDate'}, {'type': 'uint256', 'name': 'protoElapsed'}, {'type': 'uint256', 'name': 'protoCollapseDate'}, {'type': 'uint256', 'name': 'protoNextDue'}, {'type': 'uint256', 'name': 'protoDueElapsed'}, {'type': 'uint256', 'name': 'protoFeesPaid'}, {'type': 'uint256', 'name': 'protoFutureFees'}, {'type': 'uint256', 'name': 'protoIncreasedDecay'}, {'type': 'uint256', 'name': 'protoFeeFroze'}, {'type': 'uint256', 'name': 'protoTotalPayable'}]}, ' BOOL': {'variables': [{'type': 'bool', 'name': 'boolInsolvent'}, {'type': 'bool', 'name': 'boolImploded'}, {'type': 'bool', 'name': 'boolCollapsed'}]}}, 'mapping': {'names': ['=>'], 'funcs': [], '=>': {'variables': [{'type': '(\tmapping(address', 'name': 'TOTALFEES)'}, {'type': '(\tmapping(address', 'name': 'PROTOOWNERS[])'}, {'type': '(\tmapping(address', 'name': 'BOOL[])'}]}}, 'modifier': {'names': ['onlyManager()', 'onlyGuard()'], 'funcs': [(['\tmodifier onlyManager() {require(_msgSender() == owner() || NeFiLib.addressInList(Managers,_msgSender()), "NOT_Manager");_;}'], '{\tmodifier onlyManager() {require(_msgSender() == owner() || NeFiLib.addressInList(Managers,_msgSender()), "NOT_Manager");_;}'), (['\tmodifier onlyGuard() {require(Guard == _msgSender() || _msgSender() == owner(), "NOT_GUARD");_;}'], '{\tmodifier onlyGuard() {require(Guard == _msgSender() || _msgSender() == owner(), "NOT_GUARD");_;}')]}, 'constructor': {'vars': [{'type': 'address[]', 'name': '_addresses'}], 'attributes': []}, 'loops': {'for': {'vars': [['uint i = 0', 'i<protoOwners.length', 'i++'], ['uint i = 0', 'i<getProtoOwnersLength(_account'], ['uint j = 0', 'j<INTgetProtoownersLength(_account'], ['uint i = 0', 'i<protos.length', 'i++'], ['uint i = 0', 'i<protos.length', 'i++'], ['uint i = 0', 'i<add.length', 'i++'], ['uint i=_x', 'i<protos.length', 'i++'], ['uint i=0', 'i<totalfees[_account].protos', 'i++'], ['uint i=0', 'i<totalfees[_account].protos', 'i++'], ['uint i=0', 'i<_intervals', 'i++'], ['uint i=0', 'i<_intervals', 'i++'], ['uint i=0', 'i<totalfees[_account].protos', 'i++'], ['uint j = 0', 'j<protoOwners.length', 'j++'], ['uint i = 0', 'i<INTgetProtoownersLength(_account'], ['uint i=0', 'i<Managers.length', 'i++']], 'funcs': [['INTreconcileAccountFees(protoOwners[i])'], ['INTreconcileFees(_account,i)'], ['    now = INTgetProtoDueElapsed(_account,j)', '    if(now < lowest && bools[_account][j].boolCollapsed != true && bools[_account][j].boolImploded != true){', '    low = j', '    lowest = INTgetProtoDueElapsed(_account,j)', '      }'], ['PROTOOWNERS storage proto = protos[i]', 'if(keccak256(bytes(proto.name)) == keccak256(bytes(_name))){', 'return true', '}'], ['PROTOOWNERS storage proto = protos[i]', 'if(keccak256(bytes(proto.name)) == keccak256(bytes(_name))){', 'return i', '}'], ['INTaddProto(bytesToAddress(add[i]),_name[i])'], ['    if(i != protos.length-1){', '  PROTOOWNERS storage proto_bef = protos[i]', '  PROTOOWNERS storage proto_now = protos[i+1]', '    BOOL storage bool_bef = boo[i]', 'BOOL storage bool_now = boo[i+1]', '            proto_bef.name =proto_now.name', 'proto_bef.protoCreationDate = proto_now.protoCreationDate', 'proto_bef.protoElapsed = proto_now.protoElapsed', 'proto_bef.protoCollapseDate = proto_now.protoCollapseDate', 'proto_bef.protoNextDue = proto_now.protoNextDue', 'proto_bef.protoDueElapsed = proto_now.protoDueElapsed', 'proto_bef.protoFutureFees = proto_now.protoFutureFees', 'proto_bef.protoIncreasedDecay = proto_now.protoIncreasedDecay', 'proto_bef.protoFeeFroze = proto_now.protoFeeFroze', 'proto_bef.protoTotalPayable = proto_now.protoTotalPayable', 'bool_bef.owed = bool_now.owed', 'bool_bef.boolInsolvent = bool_now.boolInsolvent', 'bool_bef.boolImploded = bool_now.boolImploded', 'bool_bef.boolCollapsed = bool_now.boolCollapsed', '    }'], ['totalfees[_account].totalPayable += protoowners[_account][i].protoTotalPayable', 'INTqueryProtoTotalPayable(_account,i)'], ['totalfees[_account].futureFees += protoowners[_account][i].protoFutureFees', 'INTqueryProtoFutureFees(_account,i)'], ['    INTupdateFeesPaid(_account,true,findLowest(_account),1)'], ['', 'INTupdateFeesPaid(_account,true,_x,1)'], ['if(INTgetProtoDueElapsed(_account,i)<feePeriod){', '    bools[_account][i].owed = true', '    totalfees[_account].feesOwed += 1', '    INTqueryBoolInsolvent(_account,i)', '    }else{', '    bools[_account][i].owed = false', '    }'], ['address _account = protoOwners[j]', 'for(uint i = 0;i<INTgetProtoownersLength(_account);i++) {', '    INTupdateProtoFeeFroze(_account,i,_time)', '    }'], ['    INTupdateProtoFeeFroze(_account,i,_time)'], ['Managers.pop()']]}, 'while': {'vars': [], 'funcs': []}}}}}